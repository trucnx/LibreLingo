'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var index = require('./index.js');
var path = require('path');
var path__default = _interopDefault(path);
var fs = require('fs');
var module$1 = _interopDefault(require('module'));
var rollupDependencyTree = require('rollup-dependency-tree');
var codec = require('sourcemap-codec');
var index$1 = require('./index2.js');
var env = require('./env.js');

function create_app({ bundler, manifest_data, dev_port, dev, cwd, src, dest, routes, output }) {
    if (!fs.existsSync(output))
        fs.mkdirSync(output);
    const path_to_routes = path.relative(`${output}/internal`, routes);
    const client_manifest = generate_client_manifest(manifest_data, path_to_routes, bundler, dev, dev_port);
    const server_manifest = generate_server_manifest(manifest_data, path_to_routes, cwd, src, dest, dev);
    const app = generate_app(manifest_data, path_to_routes);
    index.write_if_changed(`${output}/internal/manifest-client.mjs`, client_manifest);
    index.write_if_changed(`${output}/internal/manifest-server.mjs`, server_manifest);
    index.write_if_changed(`${output}/internal/App.svelte`, app);
}
function create_serviceworker_manifest({ manifest_data, output, client_files, static_files }) {
    let files = ['service-worker-index.html'];
    if (fs.existsSync(static_files)) {
        files = files.concat(index.walk(static_files));
    }
    else {
        // TODO remove in a future version
        if (fs.existsSync('assets')) {
            throw new Error(`As of Sapper 0.21, the assets/ directory should become static/`);
        }
    }
    const code = `
		// This file is generated by Sapper â€” do not edit it!
		export const timestamp = ${Date.now()};

		export const files = [\n\t${files.map((x) => index.stringify('/' + x)).join(',\n\t')}\n];
		export { files as assets }; // legacy

		export const shell = [\n\t${client_files.map((x) => index.stringify('/' + x)).join(',\n\t')}\n];

		export const routes = [\n\t${manifest_data.pages.map((r) => `{ pattern: ${r.pattern} }`).join(',\n\t')}\n];
	`.replace(/^\t\t/gm, '').trim();
    index.write_if_changed(`${output}/service-worker.js`, code);
}
function create_param_match(param, i) {
    return /^\.{3}.+$/.test(param)
        ? `${param.replace(/.{3}/, '')}: d(match[${i + 1}]).split('/')`
        : `${param}: d(match[${i + 1}])`;
}
function generate_client_manifest(manifest_data, path_to_routes, bundler, dev, dev_port) {
    const page_ids = new Set(manifest_data.pages.map(page => page.pattern.toString()));
    const server_routes_to_ignore = manifest_data.server_routes.filter(route => !page_ids.has(route.pattern.toString()));
    const component_indexes = {};
    const components = `[
		${manifest_data.components.map((component, i) => {
        const annotation = bundler === 'webpack'
            ? `/* webpackChunkName: "${component.name}" */ `
            : '';
        const source = get_file(path_to_routes, component);
        component_indexes[component.name] = i;
        return `{
					js: () => import(${annotation}${index.stringify(source)}),
					css: "__SAPPER_CSS_PLACEHOLDER:${index.stringify(component.file, false)}__"
				}`;
    }).join(',\n\t\t\t\t')}
	]`.replace(/^\t/gm, '');
    let needs_decode = false;
    let routes = `[
				${manifest_data.pages.map(page => `{
					// ${page.parts[page.parts.length - 1].component.file}
					pattern: ${page.pattern},
					parts: [
						${page.parts.map(part => {
        const missing_layout = !part;
        if (missing_layout)
            return 'null';
        if (part.params.length > 0) {
            needs_decode = true;
            const props = part.params.map(create_param_match);
            return `{ i: ${component_indexes[part.component.name]}, params: match => ({ ${props.join(', ')} }) }`;
        }
        return `{ i: ${component_indexes[part.component.name]} }`;
    }).join(',\n\t\t\t\t\t\t')}
					]
				}`).join(',\n\n\t\t\t\t')}
	]`.replace(/^\t/gm, '');
    if (needs_decode) {
        routes = `(d => ${routes})(decodeURIComponent)`;
    }
    return `
		// This file is generated by Sapper â€” do not edit it!
		// webpack does not support export * as root_comp yet so do a two line import/export
		import * as root_comp from '${index.stringify(get_file(path_to_routes, manifest_data.root), false)}';
		export { root_comp };
		export { default as ErrorComponent } from '${index.stringify(get_file(path_to_routes, manifest_data.error), false)}';

		export const ignore = [${server_routes_to_ignore.map(route => route.pattern).join(', ')}];

		export const components = ${components};

		export const routes = ${routes};

		${dev ? `if (typeof window !== 'undefined') {
			import(${index.stringify(index.posixify(path.resolve(__dirname, '../sapper-dev-client.js')))}).then(client => {
				client.connect(${dev_port});
			});
		}` : ''}
	`.replace(/^\t{2}/gm, '').trim();
}
function generate_server_manifest(manifest_data, path_to_routes, cwd, src, dest, dev) {
    const imports = [].concat(manifest_data.server_routes.map((route, i) => `import * as route_${i} from ${index.stringify(index.posixify(`${path_to_routes}/${route.file}`))};`), manifest_data.components.map((component, i) => `import * as component_${i} from ${index.stringify(get_file(path_to_routes, component))};`), `import * as root_comp from ${index.stringify(get_file(path_to_routes, manifest_data.root))};`, `import error from ${index.stringify(get_file(path_to_routes, manifest_data.error))};`);
    const component_lookup = {};
    manifest_data.components.forEach((component, i) => {
        component_lookup[component.name] = i;
    });
    const code = `
		`.replace(/^\t\t/gm, '').trim();
    const build_dir = index.posixify(path.normalize(path.relative(cwd, dest)));
    const src_dir = index.posixify(path.normalize(path.relative(cwd, src)));
    return `
		// This file is generated by Sapper â€” do not edit it!
		${imports.join('\n')}

		const d = decodeURIComponent;

		export const manifest = {
			server_routes: [
				${manifest_data.server_routes.map((route, i) => `{
					// ${route.file}
					pattern: ${route.pattern},
					handlers: route_${i},
					params: ${route.params.length > 0
        ? `match => ({ ${route.params.map(create_param_match).join(', ')} })`
        : `() => ({})`}
				}`).join(',\n\n\t\t\t\t')}
			],

			pages: [
				${manifest_data.pages.map(page => `{
					// ${page.parts[page.parts.length - 1].component.file}
					pattern: ${page.pattern},
					parts: [
						${page.parts.map(part => {
        if (part === null)
            return 'null';
        const props = [
            `name: "${part.component.name}"`,
            `file: ${index.stringify(part.component.file)}`,
            `component: component_${component_lookup[part.component.name]}`
        ].filter(Boolean);
        if (part.params.length > 0) {
            const params = part.params.map(create_param_match);
            props.push(`params: match => ({ ${params.join(', ')} })`);
        }
        return `{ ${props.join(', ')} }`;
    }).join(',\n\t\t\t\t\t\t')}
					]
				}`).join(',\n\n\t\t\t\t')}
			],

			root_comp,
			error
		};

		export const build_dir = ${JSON.stringify(build_dir)};

		export const src_dir = ${JSON.stringify(src_dir)};

		export const dev = ${dev ? 'true' : 'false'};
	`.replace(/^\t{2}/gm, '').trim();
}
function generate_app(manifest_data, path_to_routes) {
    // TODO remove default layout altogether
    const max_depth = Math.max(...manifest_data.pages.map(page => page.parts.filter(Boolean).length));
    const levels = [];
    for (let i = 0; i < max_depth; i += 1) {
        levels.push(i + 1);
    }
    let l = max_depth;
    let pyramid = `<svelte:component this="{level${l}.component}" {...level${l}.props}/>`;
    while (l-- > 1) {
        pyramid = `
			<svelte:component this="{level${l}.component}" segment="{segments[${l}]}" {...level${l}.props}>
				{#if level${l + 1}}
					${pyramid.replace(/\n/g, '\n\t\t\t\t\t')}
				{/if}
			</svelte:component>
		`.replace(/^\t\t\t/gm, '').trim();
    }
    return `
		<!-- This file is generated by Sapper â€” do not edit it! -->
		<script>
			import { setContext, afterUpdate } from 'svelte';
			import { CONTEXT_KEY } from './shared';
			import Layout from '${get_file(path_to_routes, manifest_data.root)}';
			import Error from '${get_file(path_to_routes, manifest_data.error)}';

			export let stores;
			export let error;
			export let status;
			export let segments;
			export let level0;
			${levels.map(l => `export let level${l} = null;`).join('\n\t\t\t')}
			export let notify;

			afterUpdate(notify);
			setContext(CONTEXT_KEY, stores);
		</script>

		<Layout segment="{segments[0]}" {...level0.props}>
			{#if error}
				<Error {error} {status}/>
			{:else}
				${pyramid.replace(/\n/g, '\n\t\t\t\t')}
			{/if}
		</Layout>
	`.replace(/^\t\t/gm, '').trim();
}
function get_file(path_to_routes, component) {
    if (component.default)
        return `./${component.type}.svelte`;
    return index.posixify(`${path_to_routes}/${component.file}`);
}

var modules = {};

var getModule = function(dir) {
  var rootPath = dir ? path__default.resolve(dir) : process.cwd();
  var rootName = path__default.join(rootPath, '@root');
  var root = modules[rootName];
  if (!root) {
    root = new module$1(rootName);
    root.filename = rootName;
    root.paths = module$1._nodeModulePaths(rootPath);
    modules[rootName] = root;
  }
  return root;
};

var requireRelative = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return root.require(requested);
};

requireRelative.resolve = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return module$1._resolveFilename(requested, root);
};

var requireRelative_1 = requireRelative;

const inline_sourcemap_header = 'data:application/json;charset=utf-8;base64,';
function extract_sourcemap(raw, id) {
    let raw_map = undefined;
    let map = null;
    const code = raw.replace(/\/\*#\s+sourceMappingURL=(.+)\s+\*\//g, (m, url) => {
        if (raw_map) {
            // TODO should not happen!
            throw new Error(`Found multiple sourcemaps in single file (${id})`);
        }
        raw_map = url;
        return '';
    }).trim();
    if (typeof raw_map === 'string') {
        if (raw_map.startsWith(inline_sourcemap_header)) {
            const json = Buffer.from(raw_map.slice(inline_sourcemap_header.length), 'base64').toString();
            map = JSON.parse(json);
        }
    }
    return {
        code,
        map
    };
}
function chunk_content_from_modules(modules, resolve) {
    const parts = [];
    const mappings = [];
    const sources = [];
    const sourcesContent = [];
    const names = [];
    for (const module of modules) {
        const { code, map } = resolve(module);
        parts.push(code);
        if (map) {
            const lines = codec.decode(map.mappings);
            if (sources.length > 0 || names.length > 0) {
                for (const line of lines) {
                    for (const segment of line) {
                        // adjust source index
                        if (segment[1] !== undefined)
                            segment[1] += sources.length;
                        // adjust name index
                        if (segment[4])
                            segment[4] += names.length;
                    }
                }
            }
            sources.push(...map.sources);
            sourcesContent.push(...map.sourcesContent);
            names.push(...map.names);
            mappings.push(...lines);
        }
    }
    if (parts.length > 0) {
        return {
            code: parts.join('\n'),
            map: {
                version: 3,
                file: null,
                sources,
                sourcesContent,
                names,
                mappings: codec.encode(mappings)
            }
        };
    }
    throw new Error("Internal error: no content available for chunk");
}
function emit_code_and_sourcemap({ sourcemap, sourcemap_url_prefix, output_file_name, output: { map, code }, emit }) {
    map = Object.assign({}, map, { file: output_file_name });
    if (sourcemap === true) {
        const sourcemap_path = emit(`${output_file_name}.map`, JSON.stringify(map, null, '	'));
        code += `\n/*# sourceMappingURL=${sourcemap_url_prefix}${sourcemap_path} */`;
    }
    if (sourcemap === 'inline') {
        const base64 = Buffer.from(JSON.stringify(map), 'utf8').toString('base64');
        code += `\n/*# sourceMappingURL=${inline_sourcemap_header}${base64} */`;
    }
    return emit(output_file_name, code);
}

var version = "1.0.1";

class RollupResult {
    constructor(duration, compiler, sourcemap) {
        this.duration = duration;
        this.sourcemap = sourcemap;
        this.errors = compiler.errors.map(munge_warning_or_error);
        this.warnings = compiler.warnings.map(munge_warning_or_error);
        this.chunks = compiler.chunks.map(chunk => ({
            file: chunk.fileName,
            imports: chunk.imports.filter(Boolean),
            modules: Object.keys(chunk.modules).map(m => index.normalize_path(m))
        }));
        this.dependencies = compiler.dependencies;
        this.assets = {
            main: compiler.js_main
        };
        this.css = {
            main: compiler.css_main
        };
        this.summary = compiler.chunks.map(chunk => {
            const size_color = chunk.code.length > 150000 ? index.$.bold().red : chunk.code.length > 50000 ? index.$.bold().yellow : index.$.bold().white;
            const size_label = index.left_pad(index$1.prettyBytes(chunk.code.length), 10);
            const lines = [size_color(`${size_label} ${chunk.fileName}`)];
            const deps = Object.keys(chunk.modules)
                .map(file => {
                return {
                    file: path.relative(process.cwd(), file),
                    size: chunk.modules[file].renderedLength
                };
            })
                .filter(dep => dep.size > 0)
                .sort((a, b) => b.size - a.size);
            const total_unminified = deps.reduce((t, d) => t + d.size, 0);
            deps.forEach((dep, i) => {
                const c = i === deps.length - 1 ? 'â””' : 'â”‚';
                let line = `           ${c} ${dep.file}`;
                if (deps.length > 1) {
                    const p = (100 * dep.size / total_unminified).toFixed(1);
                    line += ` (${p}%)`;
                }
                lines.push(index.$.gray(line));
            });
            return lines.join('\n');
        }).join('\n');
    }
    relative_dependencies(routes_dir) {
        const dependencies = {};
        Object.entries(this.dependencies).forEach(([key, value]) => {
            dependencies[index.normalize_path(path.relative(routes_dir, key)).replace(/\\/g, '/')] = value;
        });
        return dependencies;
    }
    to_json(manifest_data, dirs) {
        const dependencies = (this.relative_dependencies(dirs.routes));
        return {
            bundler: 'rollup',
            shimport: version,
            assets: this.assets,
            css: this.css,
            dependencies
        };
    }
    print() {
        const blocks = this.warnings.map(warning => {
            return warning.file
                ? `> ${index.$.bold(warning.file)}\n${warning.message}`
                : `> ${warning.message}`;
        });
        blocks.push(this.summary);
        return blocks.join('\n\n');
    }
}
function munge_warning_or_error(warning_or_error) {
    return {
        file: warning_or_error.filename,
        message: [warning_or_error.message, warning_or_error.frame].filter(Boolean).join('\n')
    };
}

const stderr = console.error.bind(console);
let rollup;
const get_entry_point_output_chunk = (bundle, entry_point) => {
    if (entry_point === undefined) {
        throw new Error("Internal error: entry_point cannot be undefined");
    }
    let entry_point_output_chunk;
    for (const chunk of Object.values(bundle)) {
        if (chunk.facadeModuleId === entry_point) {
            entry_point_output_chunk = chunk;
        }
    }
    if (!entry_point_output_chunk) {
        throw new Error(`Internal error: No chunk for entry point: ${entry_point} in: ${Object.keys(bundle)}`);
    }
    if (entry_point_output_chunk.type !== 'chunk') {
        throw new Error(`Internal error: Wrong type for entry point chunk: ${entry_point} in: ${Object.keys(bundle)}`);
    }
    return entry_point_output_chunk;
};
class RollupCompiler {
    constructor(config, routes) {
        this._ = this.get_config(config);
        this.js_main = null;
        this.css_main = [];
        this.warnings = [];
        this.errors = [];
        this.chunks = [];
        this.css_files = {};
        this.dependencies = {};
        this.routes = routes;
    }
    get_config(mod) {
        return index.__awaiter(this, void 0, void 0, function* () {
            let entry_point;
            const that = this;
            const sourcemap = mod.output.sourcemap;
            // TODO this is hacky, and doesn't need to apply to all three compilers
            (mod.plugins || (mod.plugins = [])).push({
                name: 'sapper-internal',
                buildStart(options) {
                    const input = options.input;
                    const inputs = [];
                    if (typeof input === 'string') {
                        inputs.push({ alias: 'main', file: input });
                    }
                    else if (Array.isArray(input)) {
                        inputs.push(...input.map(file => ({ file, alias: file })));
                    }
                    else {
                        for (const alias in input) {
                            inputs.push({ file: input[alias], alias });
                        }
                    }
                    if (!entry_point) {
                        entry_point = inputs[0].file;
                    }
                },
                renderChunk(code, chunk) {
                    that.chunks.push(chunk);
                },
                transform(code, id) {
                    // rollup-plugin-svelte adds an import statement to the js file which references the css file
                    // that won't be able to be compiled as js, so we remove it here and store a copy to use later
                    if (/\.css$/.test(id)) {
                        that.css_files[id] = code;
                        return { code: '', moduleSideEffects: 'no-treeshake' };
                    }
                },
                generateBundle(options, bundle) {
                    return index.__awaiter(this, void 0, void 0, function* () {
                        const create_chunk_from_modules = (entry_chunk_name, css_modules) => {
                            const name = entry_chunk_name + '.css';
                            const file_name = emit_code_and_sourcemap({
                                sourcemap,
                                output: chunk_content_from_modules(css_modules, css_module => {
                                    const code = that.css_files[css_module];
                                    return code && extract_sourcemap(code, css_module);
                                }),
                                sourcemap_url_prefix: '',
                                output_file_name: name,
                                emit: (filename, source) => {
                                    const moduleid = this.emitFile({ name: filename, type: 'asset', source });
                                    const file = this.getFileName(moduleid);
                                    return file;
                                }
                            });
                            return file_name;
                        };
                        function js_deps(chunk, opts) {
                            return Array.from(rollupDependencyTree.dependenciesForTree(chunk, that.chunks, opts));
                        }
                        function css_deps(transitive_deps) {
                            const result = new Set();
                            for (const dep of transitive_deps) {
                                const css_chunk = css_for_chunk[dep];
                                if (css_chunk) {
                                    result.add(css_chunk);
                                }
                            }
                            return Array.from(result);
                        }
                        const css_for_chunk = {};
                        const processed_chunks = new Set();
                        /**
                         * Creates a single CSS chunk for the given JS chunks
                         */
                        function handle_chunks(tree_entry_chunk, chunks) {
                            const css_modules = new Set();
                            for (const chunk of chunks) {
                                processed_chunks.add(chunk);
                                Object.keys(chunk.modules).filter(k => k.endsWith('.css')).forEach(m => css_modules.add(m));
                            }
                            if (css_modules.size) {
                                css_for_chunk[tree_entry_chunk.fileName] = create_chunk_from_modules(tree_entry_chunk.name, css_modules);
                            }
                        }
                        /**
                         * Creates CSS chunks for the given JS chunk and its dependencies
                         */
                        function handle_chunk_tree(tree_entry_chunk, subtree) {
                            // We need to avoid the entry chunk both here and below so that we don't walk everything
                            // We should remove the ciricular dependency in Sapper so that this isn't a concern
                            const transitive_deps = js_deps(tree_entry_chunk, {
                                filter: ctx => ctx.chunk.fileName !== tree_entry_chunk.fileName,
                                walk: ctx => !ctx.dynamicImport && ctx.chunk.fileName !== entry_chunk.fileName
                            });
                            for (const chunk of transitive_deps) {
                                if (!processed_chunks.has(chunk)) {
                                    handle_chunks(chunk, [chunk]);
                                }
                            }
                            // Put everything that's leftover into the entry chunk in order to include css
                            // that is in a dynamically imported chunk
                            const chunks_for_tree = js_deps(tree_entry_chunk, { walk: ctx => !subtree || ctx.chunk.fileName !== entry_chunk.fileName });
                            const unused = new Set(chunks_for_tree.filter(x => !processed_chunks.has(x)));
                            handle_chunks(tree_entry_chunk, unused);
                        }
                        function get_route_entry_chunks(main_entry_chunk) {
                            return js_deps(main_entry_chunk, { filter: ctx => ctx.dynamicImport
                                    && ctx.chunk.facadeModuleId
                                    && ctx.chunk.facadeModuleId.includes(that.routes)
                                    && !ctx.chunk.facadeModuleId.includes(path.sep + '_') });
                        }
                        // Create the CSS chunks. Start with the routes. Put the leftover in the entry
                        // chunk to handle dynamic imports in the layout
                        const entry_chunk = get_entry_point_output_chunk(bundle, entry_point);
                        const route_entry_chunks = get_route_entry_chunks(entry_chunk);
                        for (const route_entry_chunk of route_entry_chunks) {
                            handle_chunk_tree(route_entry_chunk, true);
                        }
                        handle_chunk_tree(entry_chunk);
                        // Store the build dependencies so that we can create build.json
                        const dependencies = {};
                        // We need to handle the entry point separately
                        // If there's a single page and preserveEntrySignatures is false then Rollup will
                        // put everything in the entry point chunk (client.hash.js)
                        // In that case we can't look it up by route, but still want to include it
                        that.js_main = entry_chunk.fileName;
                        // We consider the dependencies of the entry chunk as well when finding the CSS in
                        // case preserveEntrySignatures is true and there are multiple chunks
                        that.css_main = css_deps(js_deps(entry_chunk, { walk: ctx => !ctx.dynamicImport }).map(c => c.fileName));
                        // Routes dependencies
                        for (const chunk of route_entry_chunks) {
                            const js_dependencies = js_deps(chunk, { walk: ctx => !ctx.dynamicImport && ctx.chunk.fileName !== entry_chunk.fileName }).map(c => c.fileName);
                            const css_dependencies = css_deps(js_dependencies);
                            dependencies[chunk.facadeModuleId] = [...js_dependencies, ...css_dependencies];
                        }
                        that.dependencies = dependencies;
                    });
                }
            });
            const onwarn = mod.onwarn || ((warning, handler) => {
                handler(warning);
            });
            mod.onwarn = (warning) => {
                onwarn(warning, (warn) => {
                    this.warnings.push(warn);
                });
            };
            return mod;
        });
    }
    oninvalid(cb) {
        this._oninvalid = cb;
    }
    compile() {
        return index.__awaiter(this, void 0, void 0, function* () {
            const config = yield this._;
            const sourcemap = config.output.sourcemap;
            const start = Date.now();
            try {
                const bundle = yield rollup.rollup(config);
                yield bundle.write(config.output);
                return new RollupResult(Date.now() - start, this, sourcemap);
            }
            catch (err) {
                // flush warnings
                stderr(new RollupResult(Date.now() - start, this, sourcemap).print());
                handleError(err);
            }
        });
    }
    watch(cb) {
        return index.__awaiter(this, void 0, void 0, function* () {
            const config = yield this._;
            const sourcemap = config.output.sourcemap;
            const watcher = rollup.watch(config);
            watcher.on('change', (id) => {
                this.chunks = [];
                this.warnings = [];
                this.errors = [];
                this._oninvalid(id);
            });
            watcher.on('event', (event) => {
                switch (event.code) {
                    case 'FATAL':
                        // TODO kill the process?
                        if (event.error.filename) {
                            // TODO this is a bit messy. Also, can
                            // Rollup emit other kinds of error?
                            event.error.message = [
                                `Failed to build â€” error in ${event.error.filename}: ${event.error.message}`,
                                event.error.frame
                            ].filter(Boolean).join('\n');
                        }
                        cb(event.error);
                        break;
                    case 'ERROR':
                        this.errors.push(event.error);
                        cb(null, new RollupResult(Date.now() - this._start, this, sourcemap));
                        break;
                    case 'START':
                    case 'END':
                        // TODO is there anything to do with this info?
                        break;
                    case 'BUNDLE_START':
                        this._start = Date.now();
                        break;
                    case 'BUNDLE_END':
                        cb(null, new RollupResult(Date.now() - this._start, this, sourcemap));
                        break;
                    default:
                        console.log(`Unexpected event ${event.code}`);
                }
            });
        });
    }
    static load_config(cwd) {
        return index.__awaiter(this, void 0, void 0, function* () {
            if (!rollup)
                rollup = requireRelative_1('rollup', cwd);
            const input = path.resolve(cwd, 'rollup.config.js');
            const bundle = yield rollup.rollup({
                input,
                inlineDynamicImports: true,
                external: (id) => {
                    return (id[0] !== '.' && !path.isAbsolute(id)) || id.slice(-5, id.length) === '.json';
                }
            });
            const { output: [{ code }] } = yield bundle.generate({
                exports: 'named',
                format: 'cjs'
            });
            // temporarily override require
            const defaultLoader = require.extensions['.js'];
            require.extensions['.js'] = (module, filename) => {
                if (filename === input) {
                    module._compile(code, filename);
                }
                else {
                    defaultLoader(module, filename);
                }
            };
            const config = require(input).default; // eslint-disable-line
            delete require.cache[input];
            return config;
        });
    }
}
// copied from https://github.com/rollup/rollup/blob/master/cli/logging.ts
// and updated so that it will compile here
function handleError(err, recover = false) {
    let description = err.message || err;
    if (err.name)
        description = `${err.name}: ${description}`;
    const message = (err.plugin
        ? `(plugin ${(err).plugin}) ${description}`
        : description) || err;
    stderr(index.$.bold().red(`[!] ${index.$.bold(message.toString())}`));
    if (err.url) {
        stderr(index.$.cyan(err.url));
    }
    if (err.loc) {
        stderr(`${err.loc.file || err.id} (${err.loc.line}:${err.loc.column})`);
    }
    else if (err.id) {
        stderr(err.id);
    }
    if (err.frame) {
        stderr(index.$.dim(err.frame));
    }
    if (err.stack) {
        stderr(index.$.dim(err.stack));
    }
    stderr('');
    if (!recover)
        process.exit(1);
}

const { FORCE_COLOR, NODE_DISABLE_COLORS, TERM } = process.env;

const $ = {
	enabled: !NODE_DISABLE_COLORS && TERM !== 'dumb' && FORCE_COLOR !== '0',

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (str.includes(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);
	ctx.grey = $.grey.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			this.has.includes(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
	};
}

var kleur = $;

/**
 * This has been adapted from `create-react-app`, authored by Facebook, Inc.
 * see: https://github.com/facebookincubator/create-react-app/tree/master/packages/react-dev-utils
 */



const errorLabel = 'Syntax error:';
const isLikelyASyntaxError = str => str.includes(errorLabel);

const exportRegex = /\s*(.+?)\s*(")?export '(.+?)' was not found in '(.+?)'/;
const stackRegex = /^\s*at\s((?!webpack:).)*:\d+:\d+[\s\)]*(\n|$)/gm;

function formatMessage(message, isError) {
	// Workaround to accommodate Webpack v5
	// It gives us an Object now, not a string...
	// Objects not identical; details > stack > message
	if (typeof message === 'object') {
		message = message.details || message.stack || message.message;
	}

	let lines = message.split('\n');

	if (lines.length > 2 && lines[1] === '') {
		lines.splice(1, 1); // Remove extra newline.
	}

	// Remove loader notation from filenames:
	//   `./~/css-loader!./src/App.css` ~~> `./src/App.css`
	if (lines[0].lastIndexOf('!') !== -1) {
		lines[0] = lines[0].substr(lines[0].lastIndexOf('!') + 1);
	}

	// Remove useless `entry` filename stack details
	lines = lines.filter(line => line.indexOf(' @ ') !== 0);

	// 0 ~> filename; 1 ~> main err msg
	if (!lines[0] || !lines[1]) {
		return lines.join('\n');
	}

	// Cleans up verbose "module not found" messages for files and packages.
	if (lines[1].startsWith('Module not found: ')) {
		lines = [
			lines[0],
			lines[1] // "Module not found: " is enough detail
				.replace("Cannot resolve 'file' or 'directory' ", '')
				.replace('Cannot resolve module ', '')
				.replace('Error: ', '')
				.replace('[CaseSensitivePathsPlugin] ', '')
		];
	}

	// Cleans up syntax error messages.
	if (lines[1].startsWith('Module build failed: ')) {
		lines[1] = lines[1].replace('Module build failed: SyntaxError:', errorLabel);
	}

	if (lines[1].match(exportRegex)) {
		lines[1] = lines[1].replace(exportRegex, "$1 '$4' does not contain an export named '$3'.");
	}

	lines[0] = kleur.inverse(lines[0]);

	// Reassemble & Strip internal tracing, except `webpack:` -- (create-react-app/pull/1050)
	return lines.join('\n').replace(stackRegex, '').trim();
}

var webpackFormatMessages = function (stats) {
	const json = stats.toJson({}, true);

	const result = {
		errors: json.errors.map(msg => formatMessage(msg)),
		warnings: json.warnings.map(msg => formatMessage(msg))
	};

	// Only show syntax errors if we have them
	if (result.errors.some(isLikelyASyntaxError)) {
		result.errors = result.errors.filter(isLikelyASyntaxError);
	}

	// First error is usually it; others usually the same
	if (result.errors.length > 1) {
		result.errors.length = 1;
	}

	return result;
};

var formatMessage_1 = formatMessage;
webpackFormatMessages.formatMessage = formatMessage_1;

const locPattern = /\((\d+):(\d+)\)$/;
function munge_warning_or_error$1(message) {
    // TODO this is all a bit rube goldberg...
    const lines = message.split('\n');
    const file = lines.shift()
        // eslint-disable-next-line
        .replace('[7m', '') // careful â€”Â there is a special character at the beginning of this string
        .replace('[27m', '')
        .replace('./', '');
    const match = locPattern.exec(lines[0]);
    if (match) {
        lines[0] = lines[0].replace(locPattern, '');
    }
    return {
        file,
        message: lines.join('\n')
    };
}
class WebpackResult {
    constructor(stats) {
        this.stats = stats;
        const info = stats.toJson();
        const messages = webpackFormatMessages(stats);
        this.errors = messages.errors.map(munge_warning_or_error$1);
        this.warnings = messages.warnings.map(munge_warning_or_error$1);
        this.duration = info.time;
        this.chunks = info.assets.map((chunk) => ({ file: chunk.name }));
        this.assets = info.assetsByChunkName;
    }
    to_json(manifest_data, dirs) {
        const extract_css = (assets) => {
            assets = Array.isArray(assets) ? assets : [assets];
            return assets.find(asset => /\.css$/.test(asset));
        };
        const main_css = extract_css(this.assets.main);
        return {
            bundler: 'webpack',
            shimport: null,
            assets: this.assets,
            css: {
                main: main_css ? [main_css] : null
            }
        };
    }
    print() {
        return this.stats.toString({ colors: true });
    }
}

let webpack;
class WebpackCompiler {
    constructor(config) {
        if (!webpack)
            webpack = requireRelative_1('webpack', process.cwd());
        this._ = webpack(config);
    }
    oninvalid(cb) {
        this._.hooks.invalid.tap('sapper', cb);
    }
    compile() {
        return new Promise((fulfil, reject) => {
            this._.run((err, stats) => {
                if (err) {
                    reject(err);
                    process.exit(1);
                }
                const result = new WebpackResult(stats);
                if (result.errors.length) {
                    console.error(stats.toString({ colors: true }));
                    reject(new Error(`Encountered errors while building app`));
                }
                else {
                    fulfil(result);
                }
            });
        });
    }
    watch(cb) {
        this._.watch({}, (err, stats) => {
            cb(err, stats && new WebpackResult(stats));
        });
    }
}

function create_compilers(bundler, cwd, src, routes, dest, dev) {
    return index.__awaiter(this, void 0, void 0, function* () {
        env.set_dev(dev);
        env.set_src(src);
        env.set_dest(dest);
        if (bundler === 'rollup') {
            const config = yield RollupCompiler.load_config(cwd);
            validate_config(config, 'rollup');
            normalize_rollup_config(config.client);
            normalize_rollup_config(config.server);
            if (config.serviceworker) {
                normalize_rollup_config(config.serviceworker);
            }
            return {
                client: new RollupCompiler(config.client, routes),
                server: new RollupCompiler(config.server, routes),
                serviceworker: config.serviceworker && new RollupCompiler(config.serviceworker, routes)
            };
        }
        if (bundler === 'webpack') {
            const config = require(path.resolve(cwd, 'webpack.config.js')); // eslint-disable-line
            validate_config(config, 'webpack');
            return {
                client: new WebpackCompiler(config.client),
                server: new WebpackCompiler(config.server),
                serviceworker: config.serviceworker && new WebpackCompiler(config.serviceworker)
            };
        }
        // this shouldn't be possible...
        throw new Error(`Invalid bundler option '${bundler}'`);
    });
}
function validate_config(config, bundler) {
    if (!config.client || !config.server) {
        throw new Error(`${bundler}.config.js must export a { client, server, serviceworker? } object`);
    }
}
function normalize_rollup_config(config) {
    if (typeof config.input === 'string') {
        config.input = path.normalize(config.input);
    }
    else {
        for (const name in config.input) {
            config.input[name] = path.normalize(config.input[name]);
        }
    }
}

function create_manifest_data(cwd, extensions = '.svelte .html') {
    const component_extensions = extensions.split(' ');
    // TODO remove in a future version
    if (!fs.existsSync(cwd)) {
        throw new Error(`As of Sapper 0.21, the routes/ directory should become src/routes/`);
    }
    function find_layout(file_name, component_name, dir = '') {
        const ext = component_extensions.find((ext) => fs.existsSync(path.join(cwd, dir, `${file_name}${ext}`)));
        const file = index.posixify(path.join(dir, `${file_name}${ext}`));
        return ext
            ? {
                name: component_name,
                file
            }
            : null;
    }
    const components = [];
    const pages = [];
    const server_routes = [];
    const default_layout = {
        default: true,
        type: 'layout',
        name: '_default_layout',
        file: null
    };
    const default_error = {
        default: true,
        type: 'error',
        name: '_default_error',
        file: null
    };
    function walk(dir, parent_segments, parent_params, stack) {
        const items = fs.readdirSync(dir)
            .map(basename => {
            const resolved = path.join(dir, basename);
            const file = path.relative(cwd, resolved);
            const is_dir = fs.statSync(resolved).isDirectory();
            const ext = path.extname(basename);
            if (basename[0] === '_')
                return null;
            if (basename[0] === '.' && basename !== '.well-known')
                return null;
            if (!is_dir && !/^\.[a-z]+$/i.test(ext))
                return null; // filter out tmp files etc
            const segment = is_dir
                ? basename
                : basename.slice(0, -ext.length);
            if (/\]\[/.test(segment)) {
                throw new Error(`Invalid route ${file} â€” parameters must be separated`);
            }
            const parts = get_parts(segment);
            const is_index = is_dir ? false : basename.startsWith('index.');
            const is_page = component_extensions.indexOf(ext) !== -1;
            const route_suffix = basename.slice(basename.indexOf('.'), -ext.length);
            parts.forEach(part => {
                if (part.qualifier && /[()?:]/.test(part.qualifier.slice(1, -1))) {
                    throw new Error(`Invalid route ${file} â€” cannot use (, ), ? or : in route qualifiers`);
                }
            });
            return {
                basename,
                ext,
                parts,
                file: index.posixify(file),
                is_dir,
                is_index,
                is_page,
                route_suffix
            };
        })
            .filter(Boolean)
            .sort(comparator);
        items.forEach(item => {
            const segments = parent_segments.slice();
            if (item.is_index) {
                if (item.route_suffix) {
                    if (segments.length > 0) {
                        const last_segment = segments[segments.length - 1].slice();
                        const last_part = last_segment[last_segment.length - 1];
                        if (last_part.dynamic) {
                            last_segment.push({ dynamic: false, content: item.route_suffix });
                        }
                        else {
                            last_segment[last_segment.length - 1] = {
                                dynamic: false,
                                content: `${last_part.content}${item.route_suffix}`
                            };
                        }
                        segments[segments.length - 1] = last_segment;
                    }
                    else {
                        segments.push(item.parts);
                    }
                }
            }
            else {
                segments.push(item.parts);
            }
            const params = parent_params.slice();
            params.push(...item.parts.filter(p => p.dynamic).map(p => p.content));
            if (item.is_dir) {
                const component = find_layout('_layout', `${get_slug(item.file)}__layout`, item.file);
                if (component)
                    components.push(component);
                walk(path.join(dir, item.basename), segments, params, component
                    ? stack.concat({ component, params })
                    : stack.concat(null));
            }
            else if (item.is_page) {
                const component = {
                    name: get_slug(item.file),
                    file: item.file
                };
                components.push(component);
                const parts = (item.is_index && stack[stack.length - 1] === null)
                    ? stack.slice(0, -1).concat({ component, params })
                    : stack.concat({ component, params });
                pages.push({
                    pattern: get_pattern(segments, true),
                    parts
                });
            }
            else {
                server_routes.push({
                    name: `route_${get_slug(item.file)}`,
                    pattern: get_pattern(segments, !item.route_suffix),
                    file: item.file,
                    params
                });
            }
        });
    }
    const root = find_layout('_layout', 'main') || default_layout;
    const error = find_layout('_error', 'error') || default_error;
    walk(cwd, [], [], []);
    // check for clashes
    const seen_pages = new Map();
    pages.forEach(page => {
        const pattern = page.pattern.toString();
        if (seen_pages.has(pattern)) {
            const file = page.parts.pop().component.file;
            const other_page = seen_pages.get(pattern);
            const other_file = other_page.parts.pop().component.file;
            throw new Error(`The ${other_file} and ${file} pages clash`);
        }
        seen_pages.set(pattern, page);
    });
    const seen_routes = new Map();
    server_routes.forEach(route => {
        const pattern = route.pattern.toString();
        if (seen_routes.has(pattern)) {
            const other_route = seen_routes.get(pattern);
            throw new Error(`The ${other_route.file} and ${route.file} routes clash`);
        }
        seen_routes.set(pattern, route);
    });
    return {
        root,
        error,
        components,
        pages,
        server_routes
    };
}
function is_spread(path) {
    const spread_pattern = /\[\.{3}/g;
    return spread_pattern.test(path);
}
function comparator(a, b) {
    if (a.is_index !== b.is_index) {
        if (a.is_index)
            return is_spread(a.file) ? 1 : -1;
        return is_spread(b.file) ? -1 : 1;
    }
    const max = Math.max(a.parts.length, b.parts.length);
    for (let i = 0; i < max; i += 1) {
        const a_sub_part = a.parts[i];
        const b_sub_part = b.parts[i];
        if (!a_sub_part)
            return 1; // b is more specific, so goes first
        if (!b_sub_part)
            return -1;
        // if spread && index, order later
        if (a_sub_part.spread && b_sub_part.spread) {
            return a.is_index ? 1 : -1;
        }
        // If one is ...spread order it later
        if (a_sub_part.spread !== b_sub_part.spread)
            return a_sub_part.spread ? 1 : -1;
        if (a_sub_part.dynamic !== b_sub_part.dynamic) {
            return a_sub_part.dynamic ? 1 : -1;
        }
        if (!a_sub_part.dynamic && a_sub_part.content !== b_sub_part.content) {
            return ((b_sub_part.content.length - a_sub_part.content.length) ||
                (a_sub_part.content < b_sub_part.content ? -1 : 1));
        }
        // If both parts dynamic, check for regexp patterns
        if (a_sub_part.dynamic && b_sub_part.dynamic) {
            const regexp_pattern = /\((.*?)\)/;
            const a_match = regexp_pattern.exec(a_sub_part.content);
            const b_match = regexp_pattern.exec(b_sub_part.content);
            if (!a_match && b_match) {
                return 1; // No regexp, so less specific than b
            }
            if (!b_match && a_match) {
                return -1;
            }
            if (a_match && b_match && a_match[1] !== b_match[1]) {
                return b_match[1].length - a_match[1].length;
            }
        }
    }
}
function get_parts(part) {
    return part.split(/\[(.+?\(.+?\)|.+?)\]/)
        .map((str, i) => {
        if (!str)
            return null;
        const dynamic = i % 2 === 1;
        const [, content, qualifier] = dynamic
            ? /([^(]+)(\(.+\))?$/.exec(str)
            : [null, str, null];
        return {
            content,
            dynamic,
            spread: /^\.{3}.+$/.test(content),
            qualifier
        };
    })
        .filter(Boolean);
}
function get_slug(file) {
    let name = file
        .replace(/[\\/]index/, '')
        .replace(/[/\\]/g, '_')
        .replace(/\.\w+$/, '')
        .replace(/\[([^(]+)(?:\([^(]+\))?\]/, '$$$1')
        .replace(/[^a-zA-Z0-9_$]/g, c => {
        return c === '.' ? '_' : `$${c.charCodeAt(0)}`;
    });
    if (index.reserved_words.has(name))
        name += '_';
    return name;
}
function get_pattern(segments, add_trailing_slash) {
    const path = segments.map(segment => {
        return segment.map(part => {
            return part.dynamic
                ? part.qualifier || (part.spread ? '(.+)' : '([^/]+?)')
                : encodeURI(part.content.normalize())
                    .replace(/\?/g, '%3F')
                    .replace(/#/g, '%23')
                    .replace(/%5B/g, '[')
                    .replace(/%5D/g, ']')
                    .replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }).join('');
    }).join('\\/');
    const trailing = add_trailing_slash && segments.length ? '\\/?$' : '$';
    return new RegExp(`^\\/${path}${trailing}`);
}

exports.create_app = create_app;
exports.create_compilers = create_compilers;
exports.create_manifest_data = create_manifest_data;
exports.create_serviceworker_manifest = create_serviceworker_manifest;
exports.version = version;
//# sourceMappingURL=create_manifest_data.js.map
